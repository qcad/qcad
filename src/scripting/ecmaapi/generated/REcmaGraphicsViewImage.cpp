// ***** AUTOGENERATED CODE, DO NOT EDIT *****
            // ***** This class is not copyable.
        
        #include "REcmaGraphicsViewImage.h"
        #include "RMetaTypes.h"
        #include "../REcmaHelper.h"

        // forwards declarations mapped to includes
        
                #include "RAction.h"
            
                #include "RDocument.h"
            
                #include "RDocumentInterface.h"
            
                #include "RGraphicsSceneQt.h"
            
                #include "RGraphicsSceneDrawable.h"
            
                #include "RLine.h"
            
                #include "RSnap.h"
            
                #include "RSnapRestriction.h"
            
            
        // includes for base ecma wrapper classes
        
                  #include "REcmaGraphicsView.h"
                 void REcmaGraphicsViewImage::initEcma(QScriptEngine& engine, QScriptValue* proto 
    
    ) 
    
    {

    bool protoCreated = false;
    if(proto == NULL){
        proto = new QScriptValue(engine.newVariant(qVariantFromValue(
                (RGraphicsViewImage*) 0)));
        protoCreated = true;
    }

    
        // primary base class RGraphicsView:
        
            QScriptValue dpt = engine.defaultPrototype(
                qMetaTypeId<RGraphicsView*>());

            if (dpt.isValid()) {
                proto->setPrototype(dpt);
            }
          
        /*
        
        */
    

    QScriptValue fun;

    // toString:
    REcmaHelper::registerFunction(&engine, proto, toString, "toString");
    

    // destroy:
    REcmaHelper::registerFunction(&engine, proto, destroy, "destroy");
    
        // conversion for base class RGraphicsView
        REcmaHelper::registerFunction(&engine, proto, getRGraphicsView, "getRGraphicsView");
        

    // get class name
    REcmaHelper::registerFunction(&engine, proto, getClassName, "getClassName");
    

    // conversion to all base classes (multiple inheritance):
    REcmaHelper::registerFunction(&engine, proto, getBaseClasses, "getBaseClasses");
    

    // properties:
    

    // methods:
    
            REcmaHelper::registerFunction(&engine, proto, getNumThreads, "getNumThreads");
            
            REcmaHelper::registerFunction(&engine, proto, setNumThreads, "setNumThreads");
            
            REcmaHelper::registerFunction(&engine, proto, clear, "clear");
            
            REcmaHelper::registerFunction(&engine, proto, setViewportNumber, "setViewportNumber");
            
            REcmaHelper::registerFunction(&engine, proto, getViewportNumber, "getViewportNumber");
            
            REcmaHelper::registerFunction(&engine, proto, setNavigationAction, "setNavigationAction");
            
            REcmaHelper::registerFunction(&engine, proto, getBox, "getBox");
            
            REcmaHelper::registerFunction(&engine, proto, autoZoom, "autoZoom");
            
            REcmaHelper::registerFunction(&engine, proto, zoomTo, "zoomTo");
            
            REcmaHelper::registerFunction(&engine, proto, zoom, "zoom");
            
            REcmaHelper::registerFunction(&engine, proto, pan, "pan");
            
            REcmaHelper::registerFunction(&engine, proto, centerToBox, "centerToBox");
            
            REcmaHelper::registerFunction(&engine, proto, centerToPoint, "centerToPoint");
            
            REcmaHelper::registerFunction(&engine, proto, setGrid, "setGrid");
            
            REcmaHelper::registerFunction(&engine, proto, getGrid, "getGrid");
            
            REcmaHelper::registerFunction(&engine, proto, getFactor, "getFactor");
            
            REcmaHelper::registerFunction(&engine, proto, setFactor, "setFactor");
            
            REcmaHelper::registerFunction(&engine, proto, getOffset, "getOffset");
            
            REcmaHelper::registerFunction(&engine, proto, setOffset, "setOffset");
            
            REcmaHelper::registerFunction(&engine, proto, getBackgroundColor, "getBackgroundColor");
            
            REcmaHelper::registerFunction(&engine, proto, setMargin, "setMargin");
            
            REcmaHelper::registerFunction(&engine, proto, setColorMode, "setColorMode");
            
            REcmaHelper::registerFunction(&engine, proto, setHairlineMode, "setHairlineMode");
            
            REcmaHelper::registerFunction(&engine, proto, getHairlineMode, "getHairlineMode");
            
            REcmaHelper::registerFunction(&engine, proto, setHairlineMinimumMode, "setHairlineMinimumMode");
            
            REcmaHelper::registerFunction(&engine, proto, getHairlineMinimumMode, "getHairlineMinimumMode");
            
            REcmaHelper::registerFunction(&engine, proto, setAntialiasing, "setAntialiasing");
            
            REcmaHelper::registerFunction(&engine, proto, getAntialiasing, "getAntialiasing");
            
            REcmaHelper::registerFunction(&engine, proto, getScene, "getScene");
            
            REcmaHelper::registerFunction(&engine, proto, getDocument, "getDocument");
            
            REcmaHelper::registerFunction(&engine, proto, getDocumentInterface, "getDocumentInterface");
            
            REcmaHelper::registerFunction(&engine, proto, setExporting, "setExporting");
            
            REcmaHelper::registerFunction(&engine, proto, isExporting, "isExporting");
            
            REcmaHelper::registerFunction(&engine, proto, isPrintingOrExporting, "isPrintingOrExporting");
            
            REcmaHelper::registerFunction(&engine, proto, setPrinting, "setPrinting");
            
            REcmaHelper::registerFunction(&engine, proto, isPrinting, "isPrinting");
            
            REcmaHelper::registerFunction(&engine, proto, setPrintPreview, "setPrintPreview");
            
            REcmaHelper::registerFunction(&engine, proto, isPrintPreview, "isPrintPreview");
            
            REcmaHelper::registerFunction(&engine, proto, setPrintPointSize, "setPrintPointSize");
            
            REcmaHelper::registerFunction(&engine, proto, simulateMouseMoveEvent, "simulateMouseMoveEvent");
            
            REcmaHelper::registerFunction(&engine, proto, setTextHeightThresholdOverride, "setTextHeightThresholdOverride");
            
            REcmaHelper::registerFunction(&engine, proto, getTextHeightThresholdOverride, "getTextHeightThresholdOverride");
            
            REcmaHelper::registerFunction(&engine, proto, isGridVisible, "isGridVisible");
            
            REcmaHelper::registerFunction(&engine, proto, setGridVisible, "setGridVisible");
            
            REcmaHelper::registerFunction(&engine, proto, setScene, "setScene");
            
            REcmaHelper::registerFunction(&engine, proto, setBackgroundColor, "setBackgroundColor");
            
            REcmaHelper::registerFunction(&engine, proto, regenerate, "regenerate");
            
            REcmaHelper::registerFunction(&engine, proto, repaintView, "repaintView");
            
            REcmaHelper::registerFunction(&engine, proto, updateImage, "updateImage");
            
            REcmaHelper::registerFunction(&engine, proto, giveFocus, "giveFocus");
            
            REcmaHelper::registerFunction(&engine, proto, hasFocus, "hasFocus");
            
            REcmaHelper::registerFunction(&engine, proto, removeFocus, "removeFocus");
            
            REcmaHelper::registerFunction(&engine, proto, saveViewport, "saveViewport");
            
            REcmaHelper::registerFunction(&engine, proto, restoreViewport, "restoreViewport");
            
            REcmaHelper::registerFunction(&engine, proto, mapFromView, "mapFromView");
            
            REcmaHelper::registerFunction(&engine, proto, mapToView, "mapToView");
            
            REcmaHelper::registerFunction(&engine, proto, mapDistanceFromView, "mapDistanceFromView");
            
            REcmaHelper::registerFunction(&engine, proto, mapDistanceToView, "mapDistanceToView");
            
            REcmaHelper::registerFunction(&engine, proto, getWidth, "getWidth");
            
            REcmaHelper::registerFunction(&engine, proto, getHeight, "getHeight");
            
            REcmaHelper::registerFunction(&engine, proto, resizeImage, "resizeImage");
            
            REcmaHelper::registerFunction(&engine, proto, paintGridPoint, "paintGridPoint");
            
            REcmaHelper::registerFunction(&engine, proto, paintGridLine, "paintGridLine");
            
            REcmaHelper::registerFunction(&engine, proto, setPaintOrigin, "setPaintOrigin");
            
            REcmaHelper::registerFunction(&engine, proto, setPanOptimization, "setPanOptimization");
            
            REcmaHelper::registerFunction(&engine, proto, getPanOptimization, "getPanOptimization");
            
            REcmaHelper::registerFunction(&engine, proto, paintEntities, "paintEntities");
            
            REcmaHelper::registerFunction(&engine, proto, paintEntitiesMulti, "paintEntitiesMulti");
            
            REcmaHelper::registerFunction(&engine, proto, paintEntitiesThread, "paintEntitiesThread");
            
            REcmaHelper::registerFunction(&engine, proto, paintEntityThread, "paintEntityThread");
            
            REcmaHelper::registerFunction(&engine, proto, paintOverlay, "paintOverlay");
            
            REcmaHelper::registerFunction(&engine, proto, getBuffer, "getBuffer");
            
            REcmaHelper::registerFunction(&engine, proto, getTransform, "getTransform");
            
            REcmaHelper::registerFunction(&engine, proto, emitUpdateSnapInfo, "emitUpdateSnapInfo");
            
            REcmaHelper::registerFunction(&engine, proto, emitUpdateTextLabel, "emitUpdateTextLabel");
            
            REcmaHelper::registerFunction(&engine, proto, clearBackground, "clearBackground");
            
            REcmaHelper::registerFunction(&engine, proto, addToBackground, "addToBackground");
            
            REcmaHelper::registerFunction(&engine, proto, setBackgroundTransform, "setBackgroundTransform");
            
            REcmaHelper::registerFunction(&engine, proto, clearOverlay, "clearOverlay");
            
            REcmaHelper::registerFunction(&engine, proto, addToOverlay, "addToOverlay");
            
            REcmaHelper::registerFunction(&engine, proto, setColorCorrectionOverride, "setColorCorrectionOverride");
            
            REcmaHelper::registerFunction(&engine, proto, getColorCorrectionOverride, "getColorCorrectionOverride");
            
            REcmaHelper::registerFunction(&engine, proto, setMinimumLineweight, "setMinimumLineweight");
            
            REcmaHelper::registerFunction(&engine, proto, getMinimumLineweight, "getMinimumLineweight");
            
            REcmaHelper::registerFunction(&engine, proto, setMaximumLineweight, "setMaximumLineweight");
            
            REcmaHelper::registerFunction(&engine, proto, getMaximumLineweight, "getMaximumLineweight");
            
            REcmaHelper::registerFunction(&engine, proto, setPaintOffset, "setPaintOffset");
            
            REcmaHelper::registerFunction(&engine, proto, getPaintOffset, "getPaintOffset");
            
            REcmaHelper::registerFunction(&engine, proto, isAlphaEnabled, "isAlphaEnabled");
            
            REcmaHelper::registerFunction(&engine, proto, setAlphaEnabled, "setAlphaEnabled");
            
        engine.setDefaultPrototype(
            qMetaTypeId<RGraphicsViewImage*>(), *proto);

        
    

    QScriptValue ctor = engine.newFunction(createEcma, *proto, 2);
    
    // static methods:
    

    // static properties:
    

    // enum values:
    

    // enum conversions:
    
        
    // init class:
    engine.globalObject().setProperty("RGraphicsViewImage",
    ctor, QScriptValue::SkipInEnumeration);
    
    if( protoCreated ){
       delete proto;
    }
    
    }
     QScriptValue REcmaGraphicsViewImage::createEcma(QScriptContext* context, QScriptEngine* engine) 
    
    {
    if (context->thisObject().strictlyEquals(
       engine->globalObject())) {
       return REcmaHelper::throwError(
       QString::fromLatin1("RGraphicsViewImage(): Did you forget to construct with 'new'?"),
           context);
    }

    QScriptValue result;
        
            // generate constructor variants:
            
    if( context->argumentCount() ==
        0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ constructor:
    
            // non-copyable class:
            REcmaShellGraphicsViewImage
                    * cppResult =
                    new
                    REcmaShellGraphicsViewImage
                    ();
                
                    // TODO: triggers: Warning: QScriptEngine::newVariant(): changing class of non-QScriptObject not supported:
                    result = engine->newVariant(context->thisObject(), qVariantFromValue(cppResult));
                
        cppResult->__qtscript_self = result;
    
    } else 

    {
       return REcmaHelper::throwError(
       QString::fromLatin1("RGraphicsViewImage(): no matching constructor found."),
           context);
    }
    
    return result;
    }
    

    // conversion functions for base classes:
     QScriptValue REcmaGraphicsViewImage::getRGraphicsView(QScriptContext *context,
            QScriptEngine *engine)
        
            {
                RGraphicsView* cppResult =
                    qscriptvalue_cast<RGraphicsViewImage*> (context->thisObject());
                QScriptValue result = qScriptValueFromValue(engine, cppResult);
                return result;
            }
            

    // returns class name:
     QScriptValue REcmaGraphicsViewImage::getClassName(QScriptContext *context, QScriptEngine *engine) 
        
    {
        return qScriptValueFromValue(engine, QString("RGraphicsViewImage"));
    }
    

    // returns all base classes (in case of multiple inheritance):
     QScriptValue REcmaGraphicsViewImage::getBaseClasses(QScriptContext *context, QScriptEngine *engine) 
        
    {
        QStringList list;
        
        list.append("RGraphicsView");
    

        return qScriptValueFromSequence(engine, list);
    }
    

    // properties:
    

    // public methods:
     QScriptValue
        REcmaGraphicsViewImage::getNumThreads
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getNumThreads", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getNumThreads";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getNumThreads", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getNumThreads();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getNumThreads().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getNumThreads", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setNumThreads
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setNumThreads", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setNumThreads";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setNumThreads", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setNumThreads(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setNumThreads().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setNumThreads", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::clear
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::clear", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::clear";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("clear", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clear();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.clear().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::clear", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setViewportNumber
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setViewportNumber", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setViewportNumber";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setViewportNumber", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setViewportNumber(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setViewportNumber().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setViewportNumber", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getViewportNumber
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getViewportNumber", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getViewportNumber";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getViewportNumber", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getViewportNumber();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getViewportNumber().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getViewportNumber", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setNavigationAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setNavigationAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setNavigationAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setNavigationAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RAction * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RAction * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RAction >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RAction *RAction *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setNavigationAction(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setNavigationAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setNavigationAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getBox
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getBox", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getBox";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getBox", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RBox'
    RBox cppResult =
        
               self->getBox();
        // return type: RBox
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getBox().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getBox", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::autoZoom
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::autoZoom", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::autoZoom";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("autoZoom", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom(a0
        ,
    a1);
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.autoZoom().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::autoZoom", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::zoomTo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::zoomTo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::zoomTo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("zoomTo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomTo(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomTo(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.zoomTo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::zoomTo", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::zoom
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::zoom", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::zoom";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("zoom", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoom(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.zoom().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::zoom", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::pan
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::pan", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::pan";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("pan", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->pan(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->pan(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.pan().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::pan", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::centerToBox
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::centerToBox", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::centerToBox";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("centerToBox", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->centerToBox(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.centerToBox().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::centerToBox", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::centerToPoint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::centerToPoint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::centerToPoint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("centerToPoint", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->centerToPoint(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.centerToPoint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::centerToPoint", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setGrid
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setGrid", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setGrid";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setGrid", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGrid * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGrid * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGrid >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGrid *RGrid *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setGrid(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setGrid().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setGrid", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getGrid
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getGrid", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getGrid";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getGrid", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGrid *'
    RGrid * cppResult =
        
               self->getGrid();
        // return type: RGrid *
                // RGrid:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getGrid().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getGrid", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getFactor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getFactor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getFactor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getFactor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getFactor();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getFactor(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getFactor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getFactor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setFactor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setFactor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setFactor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setFactor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setFactor(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setFactor(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setFactor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setFactor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getOffset();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getOffset(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setOffset(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setOffset(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getBackgroundColor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getBackgroundColor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getBackgroundColor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getBackgroundColor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QColor'
    QColor cppResult =
        
               self->getBackgroundColor();
        // return type: QColor
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getBackgroundColor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getBackgroundColor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setMargin
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setMargin", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setMargin";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setMargin", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setMargin(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setMargin().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setMargin", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setColorMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setColorMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setColorMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setColorMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RGraphicsView::ColorMode */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RGraphicsView::ColorMode
                    a0 =
                    (RGraphicsView::ColorMode)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setColorMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setColorMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setColorMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setHairlineMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setHairlineMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setHairlineMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setHairlineMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setHairlineMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setHairlineMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setHairlineMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getHairlineMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getHairlineMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getHairlineMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getHairlineMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getHairlineMode();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getHairlineMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getHairlineMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setHairlineMinimumMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setHairlineMinimumMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setHairlineMinimumMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setHairlineMinimumMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setHairlineMinimumMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setHairlineMinimumMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setHairlineMinimumMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getHairlineMinimumMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getHairlineMinimumMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getHairlineMinimumMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getHairlineMinimumMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getHairlineMinimumMode();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getHairlineMinimumMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getHairlineMinimumMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setAntialiasing
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setAntialiasing", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setAntialiasing";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setAntialiasing", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setAntialiasing(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setAntialiasing().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setAntialiasing", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getAntialiasing
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getAntialiasing", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getAntialiasing";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getAntialiasing", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getAntialiasing();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getAntialiasing().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getAntialiasing", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getScene
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getScene", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getScene";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getScene", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGraphicsScene *'
    RGraphicsScene * cppResult =
        
               self->getScene();
        // return type: RGraphicsScene *
                // RGraphicsScene:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getScene().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getScene", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getDocument
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getDocument", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getDocument";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getDocument", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RDocument *'
    RDocument * cppResult =
        
               self->getDocument();
        // return type: RDocument *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getDocument().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getDocument", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getDocumentInterface
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getDocumentInterface", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getDocumentInterface";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getDocumentInterface", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RDocumentInterface *'
    RDocumentInterface * cppResult =
        
               self->getDocumentInterface();
        // return type: RDocumentInterface *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getDocumentInterface().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getDocumentInterface", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setExporting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setExporting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setExporting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setExporting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setExporting(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setExporting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setExporting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isExporting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isExporting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isExporting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isExporting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isExporting();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isExporting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isExporting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isPrintingOrExporting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isPrintingOrExporting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isPrintingOrExporting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isPrintingOrExporting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPrintingOrExporting();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isPrintingOrExporting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isPrintingOrExporting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPrinting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPrinting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPrinting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPrinting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPrinting(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPrinting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPrinting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isPrinting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isPrinting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isPrinting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isPrinting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPrinting();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isPrinting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isPrinting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPrintPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPrintPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPrintPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPrintPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPrintPreview(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPrintPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPrintPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isPrintPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isPrintPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isPrintPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isPrintPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPrintPreview();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isPrintPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isPrintPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPrintPointSize
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPrintPointSize", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPrintPointSize";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPrintPointSize", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPrintPointSize(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPrintPointSize().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPrintPointSize", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::simulateMouseMoveEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::simulateMouseMoveEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::simulateMouseMoveEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("simulateMouseMoveEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->simulateMouseMoveEvent();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.simulateMouseMoveEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::simulateMouseMoveEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setTextHeightThresholdOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setTextHeightThresholdOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setTextHeightThresholdOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setTextHeightThresholdOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setTextHeightThresholdOverride(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setTextHeightThresholdOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setTextHeightThresholdOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getTextHeightThresholdOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getTextHeightThresholdOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getTextHeightThresholdOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getTextHeightThresholdOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getTextHeightThresholdOverride();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getTextHeightThresholdOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getTextHeightThresholdOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isGridVisible
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isGridVisible", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isGridVisible";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isGridVisible", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isGridVisible();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isGridVisible().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isGridVisible", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setGridVisible
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setGridVisible", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setGridVisible";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setGridVisible", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setGridVisible(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setGridVisible().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setGridVisible", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setScene
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setScene", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setScene";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setScene", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsSceneQt * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsSceneQt * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsSceneQt >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsSceneQt *RGraphicsSceneQt *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setScene(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsSceneQt * */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsSceneQt * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsSceneQt >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsSceneQt *RGraphicsSceneQt *.", context);                    
                    }
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setScene(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setScene().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setScene", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setBackgroundColor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setBackgroundColor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setBackgroundColor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setBackgroundColor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant()
        ) /* type: QColor */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    QColor*
                    ap0 =
                    qscriptvalue_cast<
                    QColor*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QColor.",
                               context);                    
                    }
                    QColor 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setBackgroundColor(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setBackgroundColor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setBackgroundColor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::regenerate
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::regenerate", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::regenerate";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("regenerate", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerate();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerate(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.regenerate().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::regenerate", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::repaintView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::repaintView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::repaintView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("repaintView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->repaintView();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.repaintView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::repaintView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::updateImage
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::updateImage", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::updateImage";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("updateImage", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->updateImage();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.updateImage().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::updateImage", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::giveFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::giveFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::giveFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("giveFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->giveFocus();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.giveFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::giveFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::hasFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::hasFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::hasFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("hasFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->hasFocus();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.hasFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::hasFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::removeFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::removeFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::removeFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("removeFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->removeFocus();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.removeFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::removeFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::saveViewport
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::saveViewport", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::saveViewport";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("saveViewport", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->saveViewport();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.saveViewport().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::saveViewport", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::restoreViewport
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::restoreViewport", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::restoreViewport";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("restoreViewport", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->restoreViewport();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.restoreViewport().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::restoreViewport", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::mapFromView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::mapFromView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::mapFromView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("mapFromView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mapFromView(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mapFromView(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.mapFromView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::mapFromView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::mapToView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::mapToView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::mapToView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("mapToView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mapToView(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.mapToView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::mapToView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::mapDistanceFromView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::mapDistanceFromView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::mapDistanceFromView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("mapDistanceFromView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->mapDistanceFromView(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.mapDistanceFromView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::mapDistanceFromView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::mapDistanceToView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::mapDistanceToView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::mapDistanceToView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("mapDistanceToView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->mapDistanceToView(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.mapDistanceToView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::mapDistanceToView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getWidth
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getWidth", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getWidth";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getWidth", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getWidth();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getWidth().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getWidth", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getHeight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getHeight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getHeight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getHeight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getHeight();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getHeight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getHeight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::resizeImage
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::resizeImage", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::resizeImage";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("resizeImage", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->resizeImage(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.resizeImage().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::resizeImage", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintGridPoint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintGridPoint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintGridPoint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintGridPoint", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintGridPoint(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintGridPoint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintGridPoint", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintGridLine
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintGridLine", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintGridLine";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintGridLine", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLine */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RLine*
                    ap0 =
                    qscriptvalue_cast<
                    RLine*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RLine.",
                               context);                    
                    }
                    RLine 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintGridLine(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintGridLine().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintGridLine", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPaintOrigin
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPaintOrigin", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPaintOrigin";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPaintOrigin", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPaintOrigin(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPaintOrigin().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPaintOrigin", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPanOptimization
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPanOptimization", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPanOptimization";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPanOptimization", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPanOptimization(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPanOptimization().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPanOptimization", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getPanOptimization
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getPanOptimization", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getPanOptimization";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getPanOptimization", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getPanOptimization();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getPanOptimization().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getPanOptimization", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintEntities
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintEntities", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintEntities";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintEntities", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPainter * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    QPainter * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<QPainter >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QPainter *QPainter *.", context);                    
                    }
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap1 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintEntities(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintEntities().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintEntities", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintEntitiesMulti
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintEntitiesMulti", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintEntitiesMulti";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintEntitiesMulti", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintEntitiesMulti(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintEntitiesMulti().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintEntitiesMulti", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintEntitiesThread
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintEntitiesThread", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintEntitiesThread";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintEntitiesThread", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    4 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isArray()
        ) /* type: QList < REntity::Id > */
     && (
            context->argument(2).isNumber()
        ) /* type: int */
     && (
            context->argument(3).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isArray
                    QList < REntity::Id >
                    a1;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(1),
                        a1
                    );
                
                    // argument isStandardType
                    int
                    a2 =
                    (int)
                    
                    context->argument( 2 ).
                    toNumber();
                
                    // argument isStandardType
                    int
                    a3 =
                    (int)
                    
                    context->argument( 3 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintEntitiesThread(a0
        ,
    a1
        ,
    a2
        ,
    a3);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintEntitiesThread().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintEntitiesThread", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintEntityThread
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintEntityThread", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintEntityThread";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintEntityThread", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isNumber()
        ) /* type: REntity::Id */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    REntity::Id
                    a1 =
                    (REntity::Id)
                    (int)
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintEntityThread(a0
        ,
    a1);
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isNumber()
        ) /* type: REntity::Id */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    REntity::Id
                    a1 =
                    (REntity::Id)
                    (int)
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintEntityThread(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintEntityThread().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintEntityThread", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::paintOverlay
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::paintOverlay", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::paintOverlay";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("paintOverlay", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPainter * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    QPainter * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<QPainter >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type QPainter *QPainter *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintOverlay(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.paintOverlay().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::paintOverlay", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getBuffer
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getBuffer", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getBuffer";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getBuffer", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QImage'
    QImage cppResult =
        
               self->getBuffer();
        // return type: QImage
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getBuffer().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getBuffer", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getTransform
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getTransform", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getTransform";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getTransform", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QTransform'
    QTransform cppResult =
        
               self->getTransform();
        // return type: QTransform
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getTransform().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getTransform", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::emitUpdateSnapInfo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::emitUpdateSnapInfo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::emitUpdateSnapInfo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("emitUpdateSnapInfo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RSnap * */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RSnapRestriction * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RSnap * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RSnap >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RSnap *RSnap *.", context);                    
                    }
                
                    // argument is pointer
                    RSnapRestriction * a1 = NULL;

                    a1 = 
                        REcmaHelper::scriptValueTo<RSnapRestriction >(
                            context->argument(1)
                        );
                    
                    if (a1==NULL && 
                        !context->argument(1).isNull()) {
                        return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RSnapRestriction *RSnapRestriction *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->emitUpdateSnapInfo(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.emitUpdateSnapInfo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::emitUpdateSnapInfo", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::emitUpdateTextLabel
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::emitUpdateTextLabel", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::emitUpdateTextLabel";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("emitUpdateTextLabel", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTextLabel */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RTextLabel*
                    ap0 =
                    qscriptvalue_cast<
                    RTextLabel*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RTextLabel.",
                               context);                    
                    }
                    RTextLabel 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->emitUpdateTextLabel(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.emitUpdateTextLabel().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::emitUpdateTextLabel", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::clearBackground
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::clearBackground", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::clearBackground";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("clearBackground", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearBackground();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.clearBackground().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::clearBackground", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::addToBackground
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::addToBackground", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::addToBackground";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("addToBackground", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsSceneDrawable */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RGraphicsSceneDrawable*
                    ap0 =
                    qscriptvalue_cast<
                    RGraphicsSceneDrawable*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RGraphicsSceneDrawable.",
                               context);                    
                    }
                    RGraphicsSceneDrawable 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addToBackground(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.addToBackground().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::addToBackground", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setBackgroundTransform
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setBackgroundTransform", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setBackgroundTransform";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setBackgroundTransform", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setBackgroundTransform(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setBackgroundTransform().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setBackgroundTransform", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::clearOverlay
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::clearOverlay", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::clearOverlay";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("clearOverlay", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearOverlay(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isNumber()
        ) /* type: RObject::Id */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    RObject::Id
                    a1 =
                    (RObject::Id)
                    (int)
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearOverlay(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.clearOverlay().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::clearOverlay", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::addToOverlay
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::addToOverlay", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::addToOverlay";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("addToOverlay", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isNumber()
        ) /* type: RObject::Id */
     && (
            context->argument(2).isVariant() || 
            context->argument(2).isQObject() || 
            context->argument(2).isNull()
        ) /* type: RGraphicsSceneDrawable */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    RObject::Id
                    a1 =
                    (RObject::Id)
                    (int)
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RGraphicsSceneDrawable*
                    ap2 =
                    qscriptvalue_cast<
                    RGraphicsSceneDrawable*
                        >(
                        context->argument(
                        2
                        )
                    );
                    if (ap2 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 2 is not of type RGraphicsSceneDrawable.",
                               context);                    
                    }
                    RGraphicsSceneDrawable 
                    a2 = 
                    *ap2;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addToOverlay(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.addToOverlay().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::addToOverlay", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setColorCorrectionOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setColorCorrectionOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setColorCorrectionOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setColorCorrectionOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setColorCorrectionOverride(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setColorCorrectionOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setColorCorrectionOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getColorCorrectionOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getColorCorrectionOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getColorCorrectionOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getColorCorrectionOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getColorCorrectionOverride();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getColorCorrectionOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getColorCorrectionOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setMinimumLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setMinimumLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setMinimumLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setMinimumLineweight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setMinimumLineweight(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setMinimumLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setMinimumLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getMinimumLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getMinimumLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getMinimumLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getMinimumLineweight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getMinimumLineweight();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getMinimumLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getMinimumLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setMaximumLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setMaximumLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setMaximumLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setMaximumLineweight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setMaximumLineweight(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setMaximumLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setMaximumLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getMaximumLineweight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getMaximumLineweight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getMaximumLineweight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getMaximumLineweight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getMaximumLineweight();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getMaximumLineweight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getMaximumLineweight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setPaintOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setPaintOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setPaintOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setPaintOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsViewImage: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPaintOffset(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setPaintOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setPaintOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::getPaintOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::getPaintOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::getPaintOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("getPaintOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getPaintOffset();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.getPaintOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::getPaintOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::isAlphaEnabled
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::isAlphaEnabled", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::isAlphaEnabled";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("isAlphaEnabled", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isAlphaEnabled();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.isAlphaEnabled().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::isAlphaEnabled", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsViewImage::setAlphaEnabled
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsViewImage::setAlphaEnabled", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsViewImage::setAlphaEnabled";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsViewImage* self = 
                        getSelf("setAlphaEnabled", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setAlphaEnabled(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsViewImage.setAlphaEnabled().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsViewImage::setAlphaEnabled", context, engine);
            return result;
        }
         QScriptValue REcmaGraphicsViewImage::toString
    (QScriptContext *context, QScriptEngine *engine)
    
    {

    RGraphicsViewImage* self = getSelf("toString", context);
    
    QString result;
    
            result = QString("RGraphicsViewImage(0x%1)").arg((unsigned long int)self, 0, 16);
        
    return QScriptValue(result);
    }
     QScriptValue REcmaGraphicsViewImage::destroy(QScriptContext *context, QScriptEngine *engine)
    
    {

        RGraphicsViewImage* self = getSelf("RGraphicsViewImage", context);
        //Q_ASSERT(self!=NULL);
        if (self==NULL) {
            return REcmaHelper::throwError("self is NULL", context);
        }
        
    
        delete self;
        context->thisObject().setData(engine->nullValue());
        context->thisObject().prototype().setData(engine->nullValue());
        context->thisObject().setPrototype(engine->nullValue());
        context->thisObject().setScriptClass(NULL);
        return engine->undefinedValue();
    }
    RGraphicsViewImage* REcmaGraphicsViewImage::getSelf(const QString& fName, QScriptContext* context)
    
        {
            RGraphicsViewImage* self = NULL;

            
                // self could be a normal object (e.g. from an UI file) or
                // an ECMA shell object (made from an ECMA script):
                //self = getSelfShell(fName, context);
                

            //if (self==NULL) {
                self = REcmaHelper::scriptValueTo<RGraphicsViewImage >(context->thisObject())
                
                ;
            //}

            if (self == NULL){
                // avoid recursion (toString is used by the backtrace):
                if (fName!="toString") {
                    REcmaHelper::throwError(QString("RGraphicsViewImage.%1(): "
                        "This object is not a RGraphicsViewImage").arg(fName),
                        context);
                }
                return NULL;
            }

            return self;
        }
        REcmaShellGraphicsViewImage* REcmaGraphicsViewImage::getSelfShell(const QString& fName, QScriptContext* context)
    
        {
          RGraphicsViewImage* selfBase = getSelf(fName, context);
                REcmaShellGraphicsViewImage* self = dynamic_cast<REcmaShellGraphicsViewImage*>(selfBase);
                //return REcmaHelper::scriptValueTo<REcmaShellGraphicsViewImage >(context->thisObject());
            if(self == NULL){
                REcmaHelper::throwError(QString("RGraphicsViewImage.%1(): "
                    "This object is not a RGraphicsViewImage").arg(fName),
                    context);
            }

            return self;
            


        }
        