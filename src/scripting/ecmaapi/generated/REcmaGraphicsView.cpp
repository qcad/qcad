// ***** AUTOGENERATED CODE, DO NOT EDIT *****
            // ***** This class is not copyable.
        
        #include "REcmaGraphicsView.h"
        #include "RMetaTypes.h"
        #include "../REcmaHelper.h"

        // forwards declarations mapped to includes
        
                #include "RAction.h"
            
                #include "RDocumentInterface.h"
            
                #include "RGraphicsScene.h"
            
                #include "RLine.h"
            
                #include "RMouseEvent.h"
            
                #include "RTabletEvent.h"
            
                #include "RWheelEvent.h"
            
            
        // includes for base ecma wrapper classes
        
                  #include "REcmaNonCopyable.h"
                 void REcmaGraphicsView::initEcma(QScriptEngine& engine, QScriptValue* proto 
    
    ) 
    
    {

    bool protoCreated = false;
    if(proto == NULL){
        proto = new QScriptValue(engine.newVariant(qVariantFromValue(
                (RGraphicsView*) 0)));
        protoCreated = true;
    }

    
        // primary base class RNonCopyable:
        
            QScriptValue dpt = engine.defaultPrototype(
                qMetaTypeId<RNonCopyable*>());

            if (dpt.isValid()) {
                proto->setPrototype(dpt);
            }
          
        /*
        
        */
    

    QScriptValue fun;

    // toString:
    REcmaHelper::registerFunction(&engine, proto, toString, "toString");
    

    // destroy:
    REcmaHelper::registerFunction(&engine, proto, destroy, "destroy");
    

    // get class name
    REcmaHelper::registerFunction(&engine, proto, getClassName, "getClassName");
    

    // conversion to all base classes (multiple inheritance):
    REcmaHelper::registerFunction(&engine, proto, getBaseClasses, "getBaseClasses");
    

    // properties:
    

    // methods:
    
            REcmaHelper::registerFunction(&engine, proto, setViewportNumber, "setViewportNumber");
            
            REcmaHelper::registerFunction(&engine, proto, getViewportNumber, "getViewportNumber");
            
            REcmaHelper::registerFunction(&engine, proto, clear, "clear");
            
            REcmaHelper::registerFunction(&engine, proto, clearCaches, "clearCaches");
            
            REcmaHelper::registerFunction(&engine, proto, setDisplayOnlyCurrentUcs, "setDisplayOnlyCurrentUcs");
            
            REcmaHelper::registerFunction(&engine, proto, setScene, "setScene");
            
            REcmaHelper::registerFunction(&engine, proto, getScene, "getScene");
            
            REcmaHelper::registerFunction(&engine, proto, getDocument, "getDocument");
            
            REcmaHelper::registerFunction(&engine, proto, getDocumentInterface, "getDocumentInterface");
            
            REcmaHelper::registerFunction(&engine, proto, mapFromView, "mapFromView");
            
            REcmaHelper::registerFunction(&engine, proto, mapToView, "mapToView");
            
            REcmaHelper::registerFunction(&engine, proto, mapDistanceFromView, "mapDistanceFromView");
            
            REcmaHelper::registerFunction(&engine, proto, mapDistanceToView, "mapDistanceToView");
            
            REcmaHelper::registerFunction(&engine, proto, mapCornersFromView, "mapCornersFromView");
            
            REcmaHelper::registerFunction(&engine, proto, getBox, "getBox");
            
            REcmaHelper::registerFunction(&engine, proto, getMinimum, "getMinimum");
            
            REcmaHelper::registerFunction(&engine, proto, getMaximum, "getMaximum");
            
            REcmaHelper::registerFunction(&engine, proto, handleTerminateEvent, "handleTerminateEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleKeyPressEvent, "handleKeyPressEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleKeyReleaseEvent, "handleKeyReleaseEvent");
            
            REcmaHelper::registerFunction(&engine, proto, simulateMouseMoveEvent, "simulateMouseMoveEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleMouseMoveEvent, "handleMouseMoveEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleMousePressEvent, "handleMousePressEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleMouseReleaseEvent, "handleMouseReleaseEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleMouseDoubleClickEvent, "handleMouseDoubleClickEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleWheelEvent, "handleWheelEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleTabletEvent, "handleTabletEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handleSwipeGestureEvent, "handleSwipeGestureEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handlePanGestureEvent, "handlePanGestureEvent");
            
            REcmaHelper::registerFunction(&engine, proto, handlePinchGestureEvent, "handlePinchGestureEvent");
            
            REcmaHelper::registerFunction(&engine, proto, giveFocus, "giveFocus");
            
            REcmaHelper::registerFunction(&engine, proto, hasFocus, "hasFocus");
            
            REcmaHelper::registerFunction(&engine, proto, removeFocus, "removeFocus");
            
            REcmaHelper::registerFunction(&engine, proto, viewportChangeEvent, "viewportChangeEvent");
            
            REcmaHelper::registerFunction(&engine, proto, saveViewport, "saveViewport");
            
            REcmaHelper::registerFunction(&engine, proto, restoreViewport, "restoreViewport");
            
            REcmaHelper::registerFunction(&engine, proto, zoomIn, "zoomIn");
            
            REcmaHelper::registerFunction(&engine, proto, zoomOut, "zoomOut");
            
            REcmaHelper::registerFunction(&engine, proto, zoom, "zoom");
            
            REcmaHelper::registerFunction(&engine, proto, zoomTo, "zoomTo");
            
            REcmaHelper::registerFunction(&engine, proto, zoomPrevious, "zoomPrevious");
            
            REcmaHelper::registerFunction(&engine, proto, autoZoom, "autoZoom");
            
            REcmaHelper::registerFunction(&engine, proto, zoomToSelection, "zoomToSelection");
            
            REcmaHelper::registerFunction(&engine, proto, zoomToEntities, "zoomToEntities");
            
            REcmaHelper::registerFunction(&engine, proto, centerToPoint, "centerToPoint");
            
            REcmaHelper::registerFunction(&engine, proto, centerToBox, "centerToBox");
            
            REcmaHelper::registerFunction(&engine, proto, pan, "pan");
            
            REcmaHelper::registerFunction(&engine, proto, startPan, "startPan");
            
            REcmaHelper::registerFunction(&engine, proto, getFactor, "getFactor");
            
            REcmaHelper::registerFunction(&engine, proto, setFactor, "setFactor");
            
            REcmaHelper::registerFunction(&engine, proto, getOffset, "getOffset");
            
            REcmaHelper::registerFunction(&engine, proto, setOffset, "setOffset");
            
            REcmaHelper::registerFunction(&engine, proto, regenerate, "regenerate");
            
            REcmaHelper::registerFunction(&engine, proto, repaintView, "repaintView");
            
            REcmaHelper::registerFunction(&engine, proto, getWidth, "getWidth");
            
            REcmaHelper::registerFunction(&engine, proto, getHeight, "getHeight");
            
            REcmaHelper::registerFunction(&engine, proto, isActive, "isActive");
            
            REcmaHelper::registerFunction(&engine, proto, getSignalsBlocked, "getSignalsBlocked");
            
            REcmaHelper::registerFunction(&engine, proto, setSignalsBlocked, "setSignalsBlocked");
            
            REcmaHelper::registerFunction(&engine, proto, setNavigationAction, "setNavigationAction");
            
            REcmaHelper::registerFunction(&engine, proto, getGrid, "getGrid");
            
            REcmaHelper::registerFunction(&engine, proto, setGrid, "setGrid");
            
            REcmaHelper::registerFunction(&engine, proto, setGridVisible, "setGridVisible");
            
            REcmaHelper::registerFunction(&engine, proto, isGridVisible, "isGridVisible");
            
            REcmaHelper::registerFunction(&engine, proto, paintGridPoint, "paintGridPoint");
            
            REcmaHelper::registerFunction(&engine, proto, paintGridLine, "paintGridLine");
            
            REcmaHelper::registerFunction(&engine, proto, getCursor, "getCursor");
            
            REcmaHelper::registerFunction(&engine, proto, setCursor, "setCursor");
            
            REcmaHelper::registerFunction(&engine, proto, getClosestReferencePoint, "getClosestReferencePoint");
            
            REcmaHelper::registerFunction(&engine, proto, getClosestEntity, "getClosestEntity");
            
            REcmaHelper::registerFunction(&engine, proto, setBackgroundColor, "setBackgroundColor");
            
            REcmaHelper::registerFunction(&engine, proto, getBackgroundColor, "getBackgroundColor");
            
            REcmaHelper::registerFunction(&engine, proto, getMargin, "getMargin");
            
            REcmaHelper::registerFunction(&engine, proto, setMargin, "setMargin");
            
            REcmaHelper::registerFunction(&engine, proto, setExporting, "setExporting");
            
            REcmaHelper::registerFunction(&engine, proto, isExporting, "isExporting");
            
            REcmaHelper::registerFunction(&engine, proto, isPrintingOrExporting, "isPrintingOrExporting");
            
            REcmaHelper::registerFunction(&engine, proto, setPrinting, "setPrinting");
            
            REcmaHelper::registerFunction(&engine, proto, isPrinting, "isPrinting");
            
            REcmaHelper::registerFunction(&engine, proto, setPrintPreview, "setPrintPreview");
            
            REcmaHelper::registerFunction(&engine, proto, isPrintPreview, "isPrintPreview");
            
            REcmaHelper::registerFunction(&engine, proto, setPrintPointSize, "setPrintPointSize");
            
            REcmaHelper::registerFunction(&engine, proto, setColorMode, "setColorMode");
            
            REcmaHelper::registerFunction(&engine, proto, getColorMode, "getColorMode");
            
            REcmaHelper::registerFunction(&engine, proto, setHairlineMode, "setHairlineMode");
            
            REcmaHelper::registerFunction(&engine, proto, getHairlineMode, "getHairlineMode");
            
            REcmaHelper::registerFunction(&engine, proto, setHairlineMinimumMode, "setHairlineMinimumMode");
            
            REcmaHelper::registerFunction(&engine, proto, getHairlineMinimumMode, "getHairlineMinimumMode");
            
            REcmaHelper::registerFunction(&engine, proto, getTextLabels, "getTextLabels");
            
            REcmaHelper::registerFunction(&engine, proto, clearTextLabels, "clearTextLabels");
            
            REcmaHelper::registerFunction(&engine, proto, addTextLabel, "addTextLabel");
            
            REcmaHelper::registerFunction(&engine, proto, getLastKnownMousePosition, "getLastKnownMousePosition");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentStepScaleFactor, "getCurrentStepScaleFactor");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentStepScaleFactor, "setCurrentStepScaleFactor");
            
            REcmaHelper::registerFunction(&engine, proto, getCurrentStepOffset, "getCurrentStepOffset");
            
            REcmaHelper::registerFunction(&engine, proto, setCurrentStepOffset, "setCurrentStepOffset");
            
            REcmaHelper::registerFunction(&engine, proto, setTextHeightThresholdOverride, "setTextHeightThresholdOverride");
            
            REcmaHelper::registerFunction(&engine, proto, getTextHeightThresholdOverride, "getTextHeightThresholdOverride");
            
            REcmaHelper::registerFunction(&engine, proto, updateTextHeightThreshold, "updateTextHeightThreshold");
            
            REcmaHelper::registerFunction(&engine, proto, isPathVisible, "isPathVisible");
            
            REcmaHelper::registerFunction(&engine, proto, setAntialiasing, "setAntialiasing");
            
            REcmaHelper::registerFunction(&engine, proto, getAntialiasing, "getAntialiasing");
            
            REcmaHelper::registerFunction(&engine, proto, getDevicePixelRatio, "getDevicePixelRatio");
            
            REcmaHelper::registerFunction(&engine, proto, isShared, "isShared");
            
            REcmaHelper::registerFunction(&engine, proto, registerForFocus, "registerForFocus");
            
        engine.setDefaultPrototype(
            qMetaTypeId<RGraphicsView*>(), *proto);

        
    

    QScriptValue ctor = engine.newFunction(createEcma, *proto, 2);
    
    // static methods:
    

    // static properties:
    

    // enum values:
    

    ctor.setProperty("FullColor",
    QScriptValue(RGraphicsView::FullColor),
    QScriptValue::ReadOnly);


    ctor.setProperty("GrayScale",
    QScriptValue(RGraphicsView::GrayScale),
    QScriptValue::ReadOnly);


    ctor.setProperty("BlackWhite",
    QScriptValue(RGraphicsView::BlackWhite),
    QScriptValue::ReadOnly);


    // enum conversions:
    
    qScriptRegisterMetaType<RGraphicsView::ColorMode>(
        &engine,
        toScriptValueEnumColorMode,
        fromScriptValueEnumColorMode,
        ctor.property(QString::fromLatin1("prototype"))
    );

        
    // init class:
    engine.globalObject().setProperty("RGraphicsView",
    ctor, QScriptValue::SkipInEnumeration);
    
    if( protoCreated ){
       delete proto;
    }
    
    }
     QScriptValue REcmaGraphicsView::createEcma(QScriptContext* context, QScriptEngine* engine) 
    
    {
           return REcmaHelper::throwError("Abstract class RGraphicsView: Cannot be constructed.",
               context); 
    }
    

    // conversion functions for base classes:
    

    // returns class name:
     QScriptValue REcmaGraphicsView::getClassName(QScriptContext *context, QScriptEngine *engine) 
        
    {
        return qScriptValueFromValue(engine, QString("RGraphicsView"));
    }
    

    // returns all base classes (in case of multiple inheritance):
     QScriptValue REcmaGraphicsView::getBaseClasses(QScriptContext *context, QScriptEngine *engine) 
        
    {
        QStringList list;
        

        return qScriptValueFromSequence(engine, list);
    }
    

    // properties:
    

    // public methods:
     QScriptValue
        REcmaGraphicsView::setViewportNumber
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setViewportNumber", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setViewportNumber";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setViewportNumber", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setViewportNumber(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setViewportNumber().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setViewportNumber", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getViewportNumber
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getViewportNumber", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getViewportNumber";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getViewportNumber", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getViewportNumber();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getViewportNumber().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getViewportNumber", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::clear
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::clear", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::clear";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("clear", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clear();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.clear().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::clear", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::clearCaches
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::clearCaches", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::clearCaches";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("clearCaches", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearCaches();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.clearCaches().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::clearCaches", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setDisplayOnlyCurrentUcs
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setDisplayOnlyCurrentUcs", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setDisplayOnlyCurrentUcs";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setDisplayOnlyCurrentUcs", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setDisplayOnlyCurrentUcs(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setDisplayOnlyCurrentUcs().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setDisplayOnlyCurrentUcs", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setScene
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setScene", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setScene";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setScene", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsScene * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsScene * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsScene >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RGraphicsScene *RGraphicsScene *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setScene(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGraphicsScene * */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGraphicsScene * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGraphicsScene >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RGraphicsScene *RGraphicsScene *.", context);                    
                    }
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setScene(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setScene().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setScene", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getScene
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getScene", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getScene";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getScene", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGraphicsScene *'
    RGraphicsScene * cppResult =
        
               self->getScene();
        // return type: RGraphicsScene *
                // RGraphicsScene:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getScene().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getScene", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getDocument
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getDocument", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getDocument";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getDocument", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RDocument *'
    RDocument * cppResult =
        
               self->getDocument();
        // return type: RDocument *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getDocument().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getDocument", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getDocumentInterface
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getDocumentInterface", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getDocumentInterface";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getDocumentInterface", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RDocumentInterface *'
    RDocumentInterface * cppResult =
        
               self->getDocumentInterface();
        // return type: RDocumentInterface *
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getDocumentInterface().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getDocumentInterface", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::mapFromView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::mapFromView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::mapFromView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("mapFromView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mapFromView(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mapFromView(a0
        ,
    a1);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.mapFromView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::mapFromView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::mapToView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::mapToView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::mapToView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("mapToView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->mapToView(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'RBox'
    RBox cppResult =
        
               self->mapToView(a0);
        // return type: RBox
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.mapToView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::mapToView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::mapDistanceFromView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::mapDistanceFromView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::mapDistanceFromView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("mapDistanceFromView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->mapDistanceFromView(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.mapDistanceFromView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::mapDistanceFromView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::mapDistanceToView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::mapDistanceToView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::mapDistanceToView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("mapDistanceToView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->mapDistanceToView(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.mapDistanceToView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::mapDistanceToView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::mapCornersFromView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::mapCornersFromView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::mapCornersFromView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("mapCornersFromView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QList < RVector >'
    QList < RVector > cppResult =
        
               self->mapCornersFromView();
        // return type: QList < RVector >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.mapCornersFromView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::mapCornersFromView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getBox
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getBox", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getBox";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getBox", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RBox'
    RBox cppResult =
        
               self->getBox();
        // return type: RBox
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getBox().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getBox", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getMinimum
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getMinimum", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getMinimum";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getMinimum", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getMinimum();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getMinimum().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getMinimum", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getMaximum
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getMaximum", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getMaximum";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getMaximum", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getMaximum();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getMaximum().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getMaximum", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handleTerminateEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handleTerminateEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handleTerminateEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handleTerminateEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTerminateEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RTerminateEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RTerminateEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RTerminateEvent*.",
                               context);                    
                    }
                    RTerminateEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleTerminateEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handleTerminateEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handleTerminateEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handleKeyPressEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handleKeyPressEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handleKeyPressEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handleKeyPressEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant()
        ) /* type: QKeyEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QKeyEvent*
                    ap0 =
                    qscriptvalue_cast<
                    QKeyEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QKeyEvent*.",
                               context);                    
                    }
                    QKeyEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleKeyPressEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handleKeyPressEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handleKeyPressEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handleKeyReleaseEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handleKeyReleaseEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handleKeyReleaseEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handleKeyReleaseEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant()
        ) /* type: QKeyEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QKeyEvent*
                    ap0 =
                    qscriptvalue_cast<
                    QKeyEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QKeyEvent*.",
                               context);                    
                    }
                    QKeyEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleKeyReleaseEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handleKeyReleaseEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handleKeyReleaseEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::simulateMouseMoveEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::simulateMouseMoveEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::simulateMouseMoveEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("simulateMouseMoveEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->simulateMouseMoveEvent();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.simulateMouseMoveEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::simulateMouseMoveEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handleMouseMoveEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handleMouseMoveEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handleMouseMoveEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handleMouseMoveEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RMouseEvent*.",
                               context);                    
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleMouseMoveEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handleMouseMoveEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handleMouseMoveEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handleMousePressEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handleMousePressEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handleMousePressEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handleMousePressEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RMouseEvent*.",
                               context);                    
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleMousePressEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handleMousePressEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handleMousePressEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handleMouseReleaseEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handleMouseReleaseEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handleMouseReleaseEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handleMouseReleaseEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RMouseEvent*.",
                               context);                    
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleMouseReleaseEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handleMouseReleaseEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handleMouseReleaseEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handleMouseDoubleClickEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handleMouseDoubleClickEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handleMouseDoubleClickEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handleMouseDoubleClickEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RMouseEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RMouseEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RMouseEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RMouseEvent*.",
                               context);                    
                    }
                    RMouseEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleMouseDoubleClickEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handleMouseDoubleClickEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handleMouseDoubleClickEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handleWheelEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handleWheelEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handleWheelEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handleWheelEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RWheelEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RWheelEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RWheelEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RWheelEvent*.",
                               context);                    
                    }
                    RWheelEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleWheelEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handleWheelEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handleWheelEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handleTabletEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handleTabletEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handleTabletEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handleTabletEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTabletEvent */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    RTabletEvent*
                    ap0 =
                    qscriptvalue_cast<
                    RTabletEvent*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RTabletEvent*.",
                               context);                    
                    }
                    RTabletEvent& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleTabletEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handleTabletEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handleTabletEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handleSwipeGestureEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handleSwipeGestureEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handleSwipeGestureEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handleSwipeGestureEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QSwipeGesture */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QSwipeGesture*
                    ap0 =
                    qscriptvalue_cast<
                    QSwipeGesture*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QSwipeGesture*.",
                               context);                    
                    }
                    QSwipeGesture& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handleSwipeGestureEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handleSwipeGestureEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handleSwipeGestureEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handlePanGestureEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handlePanGestureEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handlePanGestureEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handlePanGestureEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPanGesture */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QPanGesture*
                    ap0 =
                    qscriptvalue_cast<
                    QPanGesture*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QPanGesture*.",
                               context);                    
                    }
                    QPanGesture& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handlePanGestureEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handlePanGestureEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handlePanGestureEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::handlePinchGestureEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::handlePinchGestureEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::handlePinchGestureEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("handlePinchGestureEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QPinchGesture */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QPinchGesture*
                    ap0 =
                    qscriptvalue_cast<
                    QPinchGesture*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QPinchGesture*.",
                               context);                    
                    }
                    QPinchGesture& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->handlePinchGestureEvent(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.handlePinchGestureEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::handlePinchGestureEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::giveFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::giveFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::giveFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("giveFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->giveFocus();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.giveFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::giveFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::hasFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::hasFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::hasFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("hasFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->hasFocus();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.hasFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::hasFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::removeFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::removeFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::removeFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("removeFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->removeFocus();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.removeFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::removeFocus", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::viewportChangeEvent
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::viewportChangeEvent", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::viewportChangeEvent";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("viewportChangeEvent", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->viewportChangeEvent();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.viewportChangeEvent().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::viewportChangeEvent", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::saveViewport
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::saveViewport", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::saveViewport";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("saveViewport", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->saveViewport();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.saveViewport().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::saveViewport", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::restoreViewport
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::restoreViewport", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::restoreViewport";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("restoreViewport", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->restoreViewport();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.restoreViewport().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::restoreViewport", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::zoomIn
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::zoomIn", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::zoomIn";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("zoomIn", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomIn();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomIn(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomIn(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.zoomIn().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::zoomIn", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::zoomOut
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::zoomOut", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::zoomOut";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("zoomOut", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomOut();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomOut(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomOut(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.zoomOut().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::zoomOut", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::zoom
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::zoom", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::zoom";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("zoom", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    double
                    a1 =
                    (double)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoom(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.zoom().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::zoom", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::zoomTo
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::zoomTo", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::zoomTo";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("zoomTo", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomTo(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomTo(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.zoomTo().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::zoomTo", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::zoomPrevious
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::zoomPrevious", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::zoomPrevious";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("zoomPrevious", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->zoomPrevious();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.zoomPrevious().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::zoomPrevious", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::autoZoom
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::autoZoom", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::autoZoom";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("autoZoom", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom(a0
        ,
    a1);
    } else


        
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isNumber()
        ) /* type: int */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
     && (
            context->argument(2).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
                    // argument isStandardType
                    bool
                    a2 =
                    (bool)
                    
                    context->argument( 2 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->autoZoom(a0
        ,
    a1
        ,
    a2);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.autoZoom().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::autoZoom", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::zoomToSelection
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::zoomToSelection", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::zoomToSelection";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("zoomToSelection", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->zoomToSelection();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->zoomToSelection(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.zoomToSelection().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::zoomToSelection", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::zoomToEntities
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::zoomToEntities", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::zoomToEntities";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("zoomToEntities", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QSet < REntity::Id > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QSet < REntity::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->zoomToEntities(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isArray()
        ) /* type: QSet < REntity::Id > */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QSet < REntity::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->zoomToEntities(a0
        ,
    a1);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.zoomToEntities().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::zoomToEntities", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::centerToPoint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::centerToPoint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::centerToPoint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("centerToPoint", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->centerToPoint(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.centerToPoint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::centerToPoint", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::centerToBox
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::centerToBox", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::centerToBox";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("centerToBox", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RBox */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RBox*
                    ap0 =
                    qscriptvalue_cast<
                    RBox*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RBox.",
                               context);                    
                    }
                    RBox 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->centerToBox(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.centerToBox().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::centerToBox", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::pan
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::pan", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::pan";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("pan", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->pan(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->pan(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.pan().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::pan", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::startPan
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::startPan", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::startPan";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("startPan", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->startPan();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.startPan().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::startPan", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getFactor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getFactor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getFactor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getFactor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getFactor();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getFactor(a0);
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getFactor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getFactor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setFactor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setFactor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setFactor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setFactor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setFactor(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: double */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setFactor(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setFactor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setFactor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getOffset();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getOffset(a0);
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setOffset(a0);
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    bool
                    a1 =
                    (bool)
                    
                    context->argument( 1 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setOffset(a0
        ,
    a1);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::regenerate
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::regenerate", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::regenerate";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("regenerate", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isArray()
        ) /* type: QSet < REntity::Id > */
    
    ){
    // prepare arguments:
    
                    // argument isArray
                    QSet < REntity::Id >
                    a0;
                    REcmaHelper::fromScriptValue(
                        engine,
                        context->argument(0),
                        a0
                    );
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerate(a0);
    } else


        
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerate();
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->regenerate(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.regenerate().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::regenerate", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::repaintView
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::repaintView", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::repaintView";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("repaintView", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->repaintView();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.repaintView().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::repaintView", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getWidth
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getWidth", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getWidth";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getWidth", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getWidth();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getWidth().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getWidth", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getHeight
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getHeight", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getHeight";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getHeight", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getHeight();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getHeight().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getHeight", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::isActive
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::isActive", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::isActive";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("isActive", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->isActive();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.isActive().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::isActive", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getSignalsBlocked
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getSignalsBlocked", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getSignalsBlocked";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getSignalsBlocked", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getSignalsBlocked();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getSignalsBlocked().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getSignalsBlocked", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setSignalsBlocked
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setSignalsBlocked", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setSignalsBlocked";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setSignalsBlocked", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setSignalsBlocked(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setSignalsBlocked().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setSignalsBlocked", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setNavigationAction
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setNavigationAction", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setNavigationAction";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setNavigationAction", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RAction * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RAction * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RAction >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RAction *RAction *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setNavigationAction(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setNavigationAction().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setNavigationAction", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getGrid
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getGrid", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getGrid";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getGrid", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGrid *'
    RGrid * cppResult =
        
               self->getGrid();
        // return type: RGrid *
                // RGrid:
                result = REcmaHelper::toScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getGrid().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getGrid", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setGrid
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setGrid", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setGrid";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setGrid", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RGrid * */
    
    ){
    // prepare arguments:
    
                    // argument is pointer
                    RGrid * a0 = NULL;

                    a0 = 
                        REcmaHelper::scriptValueTo<RGrid >(
                            context->argument(0)
                        );
                    
                    if (a0==NULL && 
                        !context->argument(0).isNull()) {
                        return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RGrid *RGrid *.", context);                    
                    }
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setGrid(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setGrid().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setGrid", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setGridVisible
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setGridVisible", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setGridVisible";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setGridVisible", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setGridVisible(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setGridVisible().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setGridVisible", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::isGridVisible
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::isGridVisible", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::isGridVisible";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("isGridVisible", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isGridVisible();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.isGridVisible().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::isGridVisible", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::paintGridPoint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::paintGridPoint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::paintGridPoint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("paintGridPoint", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintGridPoint(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.paintGridPoint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::paintGridPoint", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::paintGridLine
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::paintGridLine", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::paintGridLine";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("paintGridLine", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RLine */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RLine*
                    ap0 =
                    qscriptvalue_cast<
                    RLine*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RLine.",
                               context);                    
                    }
                    RLine 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->paintGridLine(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.paintGridLine().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::paintGridLine", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getCursor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getCursor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getCursor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getCursor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QCursor'
    QCursor cppResult =
        
               self->getCursor();
        // return type: QCursor
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getCursor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getCursor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setCursor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setCursor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setCursor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setCursor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: Qt::CursorShape */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    Qt::CursorShape
                    a0 =
                    (Qt::CursorShape)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCursor(a0);
    } else


        
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: QCursor */
    
    ){
    // prepare arguments:
    
                    // argument is reference
                    QCursor*
                    ap0 =
                    qscriptvalue_cast<
                    QCursor*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if( ap0 == NULL ){
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QCursor*.",
                               context);                    
                    }
                    QCursor& a0 = *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCursor(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setCursor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setCursor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getClosestReferencePoint
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getClosestReferencePoint", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getClosestReferencePoint";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getClosestReferencePoint", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'RRefPoint'
    RRefPoint cppResult =
        
               self->getClosestReferencePoint(a0
        ,
    a1);
        // return type: RRefPoint
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    2 && (
            context->argument(0).isNumber()
        ) /* type: REntity::Id */
     && (
            context->argument(1).isVariant() || 
            context->argument(1).isQObject() || 
            context->argument(1).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    REntity::Id
                    a0 =
                    (REntity::Id)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap1 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        1
                        )
                    );
                    if (ap1 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 1 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a1 = 
                    *ap1;
                
    // end of arguments

    // call C++ function:
    // return type 'RRefPoint'
    RRefPoint cppResult =
        
               self->getClosestReferencePoint(a0
        ,
    a1);
        // return type: RRefPoint
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getClosestReferencePoint().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getClosestReferencePoint", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getClosestEntity
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getClosestEntity", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getClosestEntity";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getClosestEntity", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    3 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
     && (
            context->argument(2).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    int
                    a2 =
                    (int)
                    
                    context->argument( 2 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'REntity::Id'
    REntity::Id cppResult =
        
               self->getClosestEntity(a0
        ,
    a1
        ,
    a2);
        // return type: REntity::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    4 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
     && (
            context->argument(2).isNumber()
        ) /* type: int */
     && (
            context->argument(3).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    int
                    a2 =
                    (int)
                    
                    context->argument( 2 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a3 =
                    (bool)
                    
                    context->argument( 3 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'REntity::Id'
    REntity::Id cppResult =
        
               self->getClosestEntity(a0
        ,
    a1
        ,
    a2
        ,
    a3);
        // return type: REntity::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
    
    if( context->argumentCount() ==
    5 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
     && (
            context->argument(1).isNumber()
        ) /* type: int */
     && (
            context->argument(2).isNumber()
        ) /* type: int */
     && (
            context->argument(3).isBool()
        ) /* type: bool */
     && (
            context->argument(4).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
                    // argument isStandardType
                    int
                    a1 =
                    (int)
                    
                    context->argument( 1 ).
                    toNumber();
                
                    // argument isStandardType
                    int
                    a2 =
                    (int)
                    
                    context->argument( 2 ).
                    toNumber();
                
                    // argument isStandardType
                    bool
                    a3 =
                    (bool)
                    
                    context->argument( 3 ).
                    toBool();
                
                    // argument isStandardType
                    bool
                    a4 =
                    (bool)
                    
                    context->argument( 4 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'REntity::Id'
    REntity::Id cppResult =
        
               self->getClosestEntity(a0
        ,
    a1
        ,
    a2
        ,
    a3
        ,
    a4);
        // return type: REntity::Id
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getClosestEntity().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getClosestEntity", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setBackgroundColor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setBackgroundColor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setBackgroundColor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setBackgroundColor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant()
        ) /* type: QColor */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    QColor*
                    ap0 =
                    qscriptvalue_cast<
                    QColor*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type QColor.",
                               context);                    
                    }
                    QColor 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setBackgroundColor(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setBackgroundColor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setBackgroundColor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getBackgroundColor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getBackgroundColor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getBackgroundColor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getBackgroundColor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QColor'
    QColor cppResult =
        
               self->getBackgroundColor();
        // return type: QColor
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getBackgroundColor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getBackgroundColor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getMargin
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getMargin", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getMargin";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getMargin", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getMargin();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getMargin().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getMargin", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setMargin
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setMargin", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setMargin";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setMargin", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setMargin(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setMargin().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setMargin", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setExporting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setExporting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setExporting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setExporting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setExporting(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setExporting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setExporting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::isExporting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::isExporting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::isExporting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("isExporting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isExporting();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.isExporting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::isExporting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::isPrintingOrExporting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::isPrintingOrExporting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::isPrintingOrExporting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("isPrintingOrExporting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPrintingOrExporting();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.isPrintingOrExporting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::isPrintingOrExporting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setPrinting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setPrinting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setPrinting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setPrinting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPrinting(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setPrinting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setPrinting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::isPrinting
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::isPrinting", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::isPrinting";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("isPrinting", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPrinting();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.isPrinting().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::isPrinting", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setPrintPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setPrintPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setPrintPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setPrintPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPrintPreview(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setPrintPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setPrintPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::isPrintPreview
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::isPrintPreview", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::isPrintPreview";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("isPrintPreview", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPrintPreview();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.isPrintPreview().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::isPrintPreview", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setPrintPointSize
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setPrintPointSize", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setPrintPointSize";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setPrintPointSize", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setPrintPointSize(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setPrintPointSize().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setPrintPointSize", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setColorMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setColorMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setColorMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setColorMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: RGraphicsView::ColorMode */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    RGraphicsView::ColorMode
                    a0 =
                    (RGraphicsView::ColorMode)
                    (int)
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setColorMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setColorMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setColorMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getColorMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getColorMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getColorMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getColorMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RGraphicsView::ColorMode'
    RGraphicsView::ColorMode cppResult =
        
               self->getColorMode();
        // return type: RGraphicsView::ColorMode
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getColorMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getColorMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setHairlineMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setHairlineMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setHairlineMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setHairlineMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setHairlineMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setHairlineMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setHairlineMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getHairlineMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getHairlineMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getHairlineMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getHairlineMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getHairlineMode();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getHairlineMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getHairlineMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setHairlineMinimumMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setHairlineMinimumMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setHairlineMinimumMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setHairlineMinimumMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setHairlineMinimumMode(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setHairlineMinimumMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setHairlineMinimumMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getHairlineMinimumMode
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getHairlineMinimumMode", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getHairlineMinimumMode";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getHairlineMinimumMode", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getHairlineMinimumMode();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getHairlineMinimumMode().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getHairlineMinimumMode", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getTextLabels
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getTextLabels", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getTextLabels";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getTextLabels", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'QList < RTextLabel >'
    QList < RTextLabel > cppResult =
        
               self->getTextLabels();
        // return type: QList < RTextLabel >
                // List of ...:
                result = REcmaHelper::listToScriptValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getTextLabels().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getTextLabels", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::clearTextLabels
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::clearTextLabels", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::clearTextLabels";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("clearTextLabels", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->clearTextLabels();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.clearTextLabels().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::clearTextLabels", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::addTextLabel
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::addTextLabel", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::addTextLabel";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("addTextLabel", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RTextLabel */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RTextLabel*
                    ap0 =
                    qscriptvalue_cast<
                    RTextLabel*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RTextLabel.",
                               context);                    
                    }
                    RTextLabel 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->addTextLabel(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.addTextLabel().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::addTextLabel", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getLastKnownMousePosition
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getLastKnownMousePosition", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getLastKnownMousePosition";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getLastKnownMousePosition", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getLastKnownMousePosition();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getLastKnownMousePosition().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getLastKnownMousePosition", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getCurrentStepScaleFactor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getCurrentStepScaleFactor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getCurrentStepScaleFactor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getCurrentStepScaleFactor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getCurrentStepScaleFactor();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getCurrentStepScaleFactor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getCurrentStepScaleFactor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setCurrentStepScaleFactor
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setCurrentStepScaleFactor", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setCurrentStepScaleFactor";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setCurrentStepScaleFactor", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: double */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    double
                    a0 =
                    (double)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentStepScaleFactor(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setCurrentStepScaleFactor().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setCurrentStepScaleFactor", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getCurrentStepOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getCurrentStepOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getCurrentStepOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getCurrentStepOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'RVector'
    RVector cppResult =
        
               self->getCurrentStepOffset();
        // return type: RVector
                // not standard type nor reference
                result = qScriptValueFromValue(engine, cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getCurrentStepOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getCurrentStepOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setCurrentStepOffset
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setCurrentStepOffset", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setCurrentStepOffset";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setCurrentStepOffset", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RVector */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RVector*
                    ap0 =
                    qscriptvalue_cast<
                    RVector*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RVector.",
                               context);                    
                    }
                    RVector 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setCurrentStepOffset(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setCurrentStepOffset().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setCurrentStepOffset", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setTextHeightThresholdOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setTextHeightThresholdOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setTextHeightThresholdOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setTextHeightThresholdOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isNumber()
        ) /* type: int */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    int
                    a0 =
                    (int)
                    
                    context->argument( 0 ).
                    toNumber();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setTextHeightThresholdOverride(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setTextHeightThresholdOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setTextHeightThresholdOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getTextHeightThresholdOverride
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getTextHeightThresholdOverride", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getTextHeightThresholdOverride";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getTextHeightThresholdOverride", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'int'
    int cppResult =
        
               self->getTextHeightThresholdOverride();
        // return type: int
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getTextHeightThresholdOverride().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getTextHeightThresholdOverride", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::updateTextHeightThreshold
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::updateTextHeightThreshold", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::updateTextHeightThreshold";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("updateTextHeightThreshold", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->updateTextHeightThreshold();
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.updateTextHeightThreshold().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::updateTextHeightThreshold", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::isPathVisible
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::isPathVisible", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::isPathVisible";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("isPathVisible", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isVariant() || 
            context->argument(0).isQObject() || 
            context->argument(0).isNull()
        ) /* type: RPainterPath */
    
    ){
    // prepare arguments:
    
                    // argument isCopyable and has default constructor and isSimpleClass 
                    RPainterPath*
                    ap0 =
                    qscriptvalue_cast<
                    RPainterPath*
                        >(
                        context->argument(
                        0
                        )
                    );
                    if (ap0 == NULL) {
                           return REcmaHelper::throwError("RGraphicsView: Argument 0 is not of type RPainterPath.",
                               context);                    
                    }
                    RPainterPath 
                    a0 = 
                    *ap0;
                
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isPathVisible(a0);
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.isPathVisible().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::isPathVisible", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::setAntialiasing
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::setAntialiasing", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::setAntialiasing";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("setAntialiasing", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    1 && (
            context->argument(0).isBool()
        ) /* type: bool */
    
    ){
    // prepare arguments:
    
                    // argument isStandardType
                    bool
                    a0 =
                    (bool)
                    
                    context->argument( 0 ).
                    toBool();
                
    // end of arguments

    // call C++ function:
    // return type 'void'
    
               self->setAntialiasing(a0);
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.setAntialiasing().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::setAntialiasing", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getAntialiasing
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getAntialiasing", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getAntialiasing";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getAntialiasing", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->getAntialiasing();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getAntialiasing().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getAntialiasing", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::getDevicePixelRatio
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::getDevicePixelRatio", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::getDevicePixelRatio";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("getDevicePixelRatio", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'double'
    double cppResult =
        
               self->getDevicePixelRatio();
        // return type: double
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.getDevicePixelRatio().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::getDevicePixelRatio", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::isShared
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::isShared", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::isShared";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("isShared", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->isShared();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.isShared().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::isShared", context, engine);
            return result;
        }
         QScriptValue
        REcmaGraphicsView::registerForFocus
        (QScriptContext* context, QScriptEngine* engine) 
        
        {
            //REcmaHelper::functionStart("REcmaGraphicsView::registerForFocus", context, engine);
            //qDebug() << "ECMAScript WRAPPER: REcmaGraphicsView::registerForFocus";
            //QCoreApplication::processEvents();

            QScriptValue result = engine->undefinedValue();
            
                    // public function: can be called from ECMA wrapper of ECMA shell:
                    RGraphicsView* self = 
                        getSelf("registerForFocus", context);
                  

                //Q_ASSERT(self!=NULL);
                if (self==NULL) {
                    return REcmaHelper::throwError("self is NULL", context);
                }
                
    
    if( context->argumentCount() ==
    0
    ){
    // prepare arguments:
    
    // end of arguments

    // call C++ function:
    // return type 'bool'
    bool cppResult =
        
               self->registerForFocus();
        // return type: bool
                // standard Type
                result = QScriptValue(cppResult);
            
    } else


        
            {
               return REcmaHelper::throwError("Wrong number/types of arguments for RGraphicsView.registerForFocus().",
                   context);
            }
            //REcmaHelper::functionEnd("REcmaGraphicsView::registerForFocus", context, engine);
            return result;
        }
         QScriptValue REcmaGraphicsView::toString
    (QScriptContext *context, QScriptEngine *engine)
    
    {

    RGraphicsView* self = getSelf("toString", context);
    
    QString result;
    
            result = QString("RGraphicsView(0x%1)").arg((unsigned long int)self, 0, 16);
        
    return QScriptValue(result);
    }
     QScriptValue REcmaGraphicsView::destroy(QScriptContext *context, QScriptEngine *engine)
    
    {

        RGraphicsView* self = getSelf("RGraphicsView", context);
        //Q_ASSERT(self!=NULL);
        if (self==NULL) {
            return REcmaHelper::throwError("self is NULL", context);
        }
        
    
        delete self;
        context->thisObject().setData(engine->nullValue());
        context->thisObject().prototype().setData(engine->nullValue());
        context->thisObject().setPrototype(engine->nullValue());
        context->thisObject().setScriptClass(NULL);
        return engine->undefinedValue();
    }
    RGraphicsView* REcmaGraphicsView::getSelf(const QString& fName, QScriptContext* context)
    
        {
            RGraphicsView* self = NULL;

            
                // self could be a normal object (e.g. from an UI file) or
                // an ECMA shell object (made from an ECMA script):
                //self = getSelfShell(fName, context);
                

            //if (self==NULL) {
                self = REcmaHelper::scriptValueTo<RGraphicsView >(context->thisObject())
                
                ;
            //}

            if (self == NULL){
                // avoid recursion (toString is used by the backtrace):
                if (fName!="toString") {
                    REcmaHelper::throwError(QString("RGraphicsView.%1(): "
                        "This object is not a RGraphicsView").arg(fName),
                        context);
                }
                return NULL;
            }

            return self;
        }
        RGraphicsView* REcmaGraphicsView::getSelfShell(const QString& fName, QScriptContext* context)
    
        {
          RGraphicsView* selfBase = getSelf(fName, context);
                RGraphicsView* self = dynamic_cast<RGraphicsView*>(selfBase);
                //return REcmaHelper::scriptValueTo<RGraphicsView >(context->thisObject());
            if(self == NULL){
                REcmaHelper::throwError(QString("RGraphicsView.%1(): "
                    "This object is not a RGraphicsView").arg(fName),
                    context);
            }

            return self;
            


        }
         QScriptValue REcmaGraphicsView::toScriptValueEnumColorMode(QScriptEngine* engine, const RGraphicsView::ColorMode& value)
    
        {
            return QScriptValue(engine, (int)value);
        }
         void REcmaGraphicsView::fromScriptValueEnumColorMode(const QScriptValue& value, RGraphicsView::ColorMode& out)
    
        {
            out = qvariant_cast<RGraphicsView::ColorMode>(value.toVariant());
        }
        